<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Black Nigth Guns</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: sans-serif;
      text-align: center;
    }
    canvas {
      background: grey;
      display: block;
      margin: 20px auto;
    }
    #restartBtn {
      display: none;
      padding: 10px 20px;
      font-size: 18px;
      background: #28a;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
    }
    #restartBtn:hover {
      background: #3cf;
    }
  </style>
</head>
<body>
  <h1>Black Nigth Guns</h1>
  <p>A/D: Mover | W/S: Subir/Bajar | Espacio: Saltar | J: Atacar | K: Disparar | R: Recargar | P: Pausa</p>
  <canvas id="game" width="800" height="420"></canvas>
  <button id="restartBtn">Reintentar</button>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const restartBtn = document.getElementById("restartBtn");

    const topLimit = 200;
    const bottomLimit = 400;
    const RELOAD_TIME = 300;
    const HEAL_TIME = 120;
    let gameOver = false;
    let paused = false;
    let kills = 0;

    class Player {
      constructor() {
        this.x = 100;
        this.y = bottomLimit - 60;
        this.vx = 0;
        this.vy = 0;
        this.w = 40;
        this.h = 60;
        this.reloadTimer = 0;
        this.healTimer = 0;
        this.speed = 3;
        this.color = "cyan";
        this.canShoot = true;
        this.healing = false;
        this.reloading = false;
        this.isJumping = false;
        this.grounded = true;
        this.attaking = false;
        this.health = 100;
        this.maxhealth = 100;
        this.attackCooldown = 0;
        this.ammo = 25;
        this.direction = 1;
        this.jumpHeight = 40;
        this.jumpDuration = 40;
        this.jumpProgress = 0;
        this.jumpOriginY = this.y;
        this.knockbackVX = 0;
        this.knockbackFrames = 0;
        this.bandages = 5;
      }

      update() {
        this.x += this.vx;
        this.x = Math.max(0, Math.min(canvas.width - this.w, this.x));

        if (this.isJumping) {
          this.jumpProgress++;
          const t = this.jumpProgress / this.jumpDuration;
          const parabola = -4 * this.jumpHeight * t * (1 - t);
          this.y = this.jumpOriginY + parabola;

          if (this.jumpProgress >= this.jumpDuration) {
            this.y = this.jumpOriginY;
            this.isJumping = false;
            this.grounded = true;
          }
        } else {
          this.y += this.vy;
          this.y = Math.max(topLimit, Math.min(bottomLimit - this.h, this.y));
        }

        if (this.attackCooldown > 0) this.attackCooldown--;

        if (this.reloading) {
          this.reloadTimer--;
          if (this.reloadTimer <= 0) {
            this.canShoot = true;
            this.reloading = false;
          }
        }
        if (this.healing){
          this.healTimer--;
          if (this.healTimer <= 0) {
            this.healing = false;
            this.health += 25;
            if (this.health > this.maxhealth) {
              this.health = this.maxhealth;
            }
          }
        }
        if (this.knockbackFrames > 0) {
          this.x += this.knockbackVX;
          this.knockbackVX *= 0.8; // amortiguación
          this.knockbackFrames--;
        }
      }
        
      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);

        ctx.fillStyle = "red";
        ctx.fillRect(this.x, this.y - 10, this.w, 5);
        ctx.fillStyle = "lime";
        ctx.fillRect(this.x, this.y - 10, this.w * (this.health / 100), 5);

        if (this.reloading) {
          const barW = 40;
          const progress = 1 - this.reloadTimer / RELOAD_TIME;
          ctx.fillStyle = "#555";
          ctx.fillRect(this.x, this.y + this.h + 5, barW, 6);
          ctx.fillStyle = "yellow";
          ctx.fillRect(this.x, this.y + this.h + 5, barW * progress, 6);
        }
        if (this.healing){
          const barW = 40;
          const progress = 1 - this.healTimer / HEAL_TIME;
          ctx.fillStyle = "#555";
          ctx.fillRect(this.x, this.y + this.h + 5, barW, 6);
          ctx.fillStyle = "yellow";
          ctx.fillRect(this.x, this.y + this.h + 5, barW * progress, 6);
        }
      }

      attack(enemy) {
        if (this.attackCooldown === 0) {
          this.attaking = true
          if (Math.abs(this.x - enemy.x) < 80 && Math.abs(this.y - enemy.y) < 50) {
            enemy.health -= 25;
            if (player.direction !== -1) {
              enemy.knockbackVX = 10;
            } else {
              enemy.knockbackVX = -10;
            }
            enemy.knockbackFrames = 10;
          }

          this.attackCooldown = 30;
          if (this.reloading) {
            this.reloading = false;
            this.reloadTimer = 0;
            this.ammo++;
          }
          if (this.healing){
            this.healing = false;
            this.healTimer = 0;
            this.bandages++
          }
        }
      }

      heal(){
      if (this.bandages > 0 && !this.healing && this.health < 100){
        if (this.reloading){
          this.healing = false;
        } else{
          this.healing =true;
          this.healTimer = HEAL_TIME;
          this.bandages--;
        }
        } 
      }

      shoot(bullets) {
        if (this.canShoot && !this.reloading) {
          const offset = this.direction === 1 ? this.w : -5;
          bullets.push(new Bullet(this.x + offset, this.y + this.h / 2, this.direction));
          this.canShoot = false;
        }
      }

      reload() {
        if (!this.canShoot && !this.reloading && this.ammo > 0) {
          if(this.healing){
            this.reloading = false;
          } else{
            this.reloading = true;
            this.reloadTimer = RELOAD_TIME;
            this.ammo--;
          }
        }
      }

      jump() {
        if (this.grounded) {
          this.jumpOriginY = this.y;
          this.jumpProgress = 0;
          this.isJumping = true;
          this.grounded = false;
        }
      }
    }

    class Ammo{
      constructor(x, y){
        this.x = x;
        this.y = y;
        this.w = 10;
        this.h = 20;
        this.color = "blue";
        this.active = true;
      }
      draw() {
        if(this.active){
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x,this.y,this.w,this.h)
        }
      }
    }
    class Heal{
      constructor(x, y){
        this.x = x;
        this.y = y;
        this.w = 10;
        this.h = 20;
        this.color = "Green";
        this.active = true;
      }
      draw() {
        if(this.active){
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x,this.y,this.w,this.h)
        }
      }
    }
    class Enemy {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 40;
        this.h = 60;
        this.speed = 1.2;
        this.color = "orange";
        this.health = 100;
        this.attackCooldown = 0;
        this.damage = 10;
        this.knockbackVX = 0;
        this.knockbackFrames = 0;

      }

      update(player) {
        let targetY = player.isJumping ? player.jumpOriginY : player.y;

        if (Math.abs(this.y - targetY) > 10) {
          this.y += this.y < targetY ? this.speed : -this.speed;
        }

        if (Math.abs(this.x - player.x) > 5) {
          this.x += this.x < player.x ? this.speed : -this.speed;
        }

        if (Math.abs(this.x - player.x) < 40 && Math.abs(this.y - player.y) < 40 && this.attackCooldown === 0) {
          if (!player.isJumping || player.attaking){
            player.health -= this.damage;
          if (player.direction != -1) {
            player.knockbackVX = -10;
          } else {
            player.knockbackVX = 10;
          }
          player.knockbackFrames = 10;

          this.attackCooldown = 60;

          }
        }

        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.knockbackFrames > 0) {
          this.x += this.knockbackVX;
          this.knockbackVX *= 0.8;
          this.knockbackFrames--;
        }

      }
      

      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = "red";
        ctx.fillRect(this.x, this.y - 10, this.w, 5);
        ctx.fillStyle = "lime";
        ctx.fillRect(this.x, this.y - 10, this.w * (this.health / 100), 5);
      }
    }

    class Bullet {
      constructor(x, y, direction) {
        this.x = x;
        this.y = y;
        this.radius = 5;
        this.speed = 8 * direction;
        this.color = "yellow";
        this.active = true;
      }

      update(enemy) {
        this.x += this.speed;
        if (Math.abs(this.x - enemy.x) < 30 && Math.abs(this.y - enemy.y) < 40) {
          enemy.health -= 50;
          this.active = false;
        }
        if (this.x < 0 || this.x > canvas.width) this.active = false;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    }

    let player, currentEnemy, bullets, resource;
    let ammoPicks =[];
    let healPicks =[];
    
    function resetGame() {
      player = new Player();
      resource = generateAmmo;
      currentEnemy = generateSafeEnemy();
      bullets = [];
      kills = 0;
      gameOver = false;
      paused = false;
      restartBtn.style.display = "none";
      gameLoop();
    }

    function generateAmmo() {
      let x, y;
      do {
        x = Math.random() * (canvas.width - 60) + 30;
      } while (Math.abs(x - player.x) < 150);

      y = Math.random() * (bottomLimit - topLimit - 60) + topLimit;
      return new Ammo(x, y);
    }
    function generateSafeEnemy() {
      let x, y;
      do {
        x = Math.random() * (canvas.width - 60) + 30;
      } while (Math.abs(x - player.x) < 150);

      y = Math.random() * (bottomLimit - topLimit - 60) + topLimit;
      return new Enemy(x, y);
    }

    const keys = {};
    window.addEventListener("keydown", e => {
      keys[e.key.toLowerCase()] = true;
      if (e.key === "Enter" && gameOver) resetGame();
      if (e.key.toLowerCase() === "p") paused = !paused;
      if (e.key.toLowerCase() === "a") player.direction = -1;
      if (e.key.toLowerCase() === "d") player.direction = 1;
    });
    window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
    restartBtn.addEventListener("click", resetGame);

    function handleInput() {
      player.vx = 0;
      player.vy = 0;
      if (keys["a"]) player.vx = -player.speed;
      if (keys["d"]) player.vx = player.speed;
      if (!player.isJumping) {
        if (keys["w"]) player.vy = -player.speed;
        if (keys["s"]) player.vy = player.speed;
      }
      if (keys[" "]) player.jump();
      if (keys["j"]) player.attack(currentEnemy);
      if (keys["k"]) player.shoot(bullets);
      if (keys["r"]) player.reload();
      if (keys['h']) player.heal();
      if (keys['f']) {
        ammoPicks.forEach(pickup =>{
          if (pickup.active && Math.abs(player.x - pickup.x) < 40 && Math.abs(player.y - pickup.y) < 40){
            player.ammo += 2;
            pickup.active = false;
          }
        });
        healPicks.forEach(pickup =>{
          if (pickup.active && Math.abs(player.x - pickup.x) < 40 && Math.abs(player.y - pickup.y) < 40){
            player.bandages += 1;
            pickup.active = false;
          }
        });
      }
    }

    function drawHUD() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, 30);
      ctx.fillStyle = "white";
      ctx.font = "14px sans-serif";
      let estado;
  if (paused) {
    estado = "PAUSADO";
  } else if (player.reloading) {
    estado = "RECARCANDO";
  } else if (player.canShoot) {
    estado = "CARGADO";
  } else if (!player.canShoot && player.ammo > 0) {
    estado = "VACÍO";
  }

  ctx.fillText(`Vida: ${player.health} |Vendajes: ${player.bandages} | Balas: ${player.canShoot ? player.ammo + 1 : player.ammo} | Enemigos derrotados: ${kills} | Estado: ${estado}`, 20, 20);
}

    function gameLoop() {
      if (gameOver) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawHUD();

      if (paused) {
        ctx.fillStyle = "white";
        ctx.font = "50px sans-serif";
        ctx.fillText("PAUSE", 330, 240);
        requestAnimationFrame(gameLoop);
        return;
      }
      
      ctx.fillStyle = "#444";
      ctx.fillRect(0, topLimit + 60, canvas.width, bottomLimit - topLimit + 60);

      handleInput();
      
      ammoPicks.forEach(p => p.draw());
      healPicks.forEach(p => p.draw());


      player.update();
      player.draw();
      
      if (currentEnemy) {
        currentEnemy.update(player);
        currentEnemy.draw();
        if (currentEnemy.health <= 0) {
          if (kills % 5 === 0){
            ammoPicks.push(new Ammo(currentEnemy.x,currentEnemy.y))
          }
          if (kills % 7 === 0){
            healPicks.push(new Heal(currentEnemy.x,currentEnemy.y))
          }
          kills++;
          currentEnemy = generateSafeEnemy();
          player.reloading = false;
        }
      }
      
      bullets.forEach(b => {
        b.update(currentEnemy);
        b.draw();
      });
      bullets = bullets.filter(b => b.active);

      if (player.health <= 0) {
        gameOver = true;
        ctx.fillStyle = "white";
        ctx.font = "40px sans-serif";
        ctx.fillText("¡Has perdido!", 300, 200);
        restartBtn.style.display = "inline-block";
        return;
      }
      ammoPicks = ammoPicks.filter(p => p.active);
      healPicks = healPicks.filter(p => p.active);


      requestAnimationFrame(gameLoop);
    }

    resetGame();
  </script>
</body>
</html>
